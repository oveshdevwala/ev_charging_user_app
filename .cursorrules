# ===============================
# EV CHARGING ADMIN PANEL .cursorrules
# ===============================

# Project: EV Charging Flutter Admin Panel
# Description: Flutter admin web panel using MVVM + BLoC + go_router + ScreenUtil + Material 3
# Platform: Web-first (Desktop → Tablet → Mobile responsive)

# ===============================
# ARCHITECTURE GOALS
# ===============================

# Build a clean, production-ready Flutter Admin Panel with:
# - Flutter (MVVM + BLoC Single-State pattern)
# - go_router (typed routing with AdminRoutes enum)
# - flutter_screenutil (responsive UI)
# - Material 3 design system
# - Barrel file exports everywhere
# - App-wide constants — NO hard-coded strings/paths
# - Reusable admin widgets, utils, wrappers
# - Sidebar + Topbar shell layout (NO separate screen navigation for tabs)

# ===============================
# ADMIN PROJECT STRUCTURE
# ===============================

# Always follow this structure:
# 
# lib/
#   admin/
#     app_admin.dart          # Admin entry point
#     admin.dart              # Barrel exports
#     core/
#       constants/            # AdminStrings, AdminAssets, AdminApiPaths
#       theme/                # AdminTheme (light/dark), AdminColors, AdminTextStyles
#       extensions/           # Admin context extensions (adminColors, goToAdmin, etc.)
#       utils/                # AdminValidators, AdminFormatters, AdminHelpers
#       config/               # AdminConfig, AdminResponsive
#       widgets/              # Reusable admin components
#     models/                 # Admin models with json_serializable
#     repositories/           # Repository implementations (dummy data)
#     services/               # CSV export, analytics, etc.
#     blocs/                  # BLoC barrel exports
#     viewmodels/             # ViewModel barrel exports
#     routes/                 # AdminRoutes enum + AdminRouter
#     features/
#       dashboard/
#         bloc/               # DashboardBloc, events, state
#         view/                # DashboardPage
#         widgets/             # Dashboard widgets
#       stations/
#         bloc/                # StationsBloc, events, state
#         repository/          # StationsRepository
#         view/                # List, Detail, Edit pages
#       [other features]/      # Same structure
#
# Generate barrel files for every folder.

# ===============================
# ADMIN NAVIGATION RULES (CRITICAL)
# ===============================

# IMPORTANT: Admin panel uses TAB-BASED navigation within AdminShell:
# - Sidebar tabs should NOT navigate to separate screens
# - Use IndexedStack or similar to switch views within AdminShell
# - Only detail/edit pages navigate (via modals or right-side panels)
# - Main tabs (Dashboard, Stations, Users, etc.) stay within shell
# - Sub-screens show as modals/sheets/panels, NOT full-screen navigation

# Navigation pattern:
# - Main tabs: Change view index in AdminShell (no navigation)
# - Detail views: Show in modal/panel/drawer from right side
# - Edit/Create: Show in modal/panel/drawer from right side
# - Only use go_router for deep links or external navigation

# Example:
# AdminShell(
#   currentViewIndex: _selectedIndex,  // Changed by sidebar
#   onViewChanged: (index) => setState(() => _selectedIndex = index),
#   child: IndexedStack(
#     index: _selectedIndex,
#     children: [DashboardPage(), StationsPage(), UsersPage(), ...],
#   ),
# )

# ===============================
# BLoC RULES (Same as User App)
# ===============================

# Single-state classes ONLY:
# - Must extend Equatable
# - Must include copyWith() method
# - NO business logic inside UI
# - Bloc does not hold mutable collections
# - Always initialize state in constructor
# - Handle error and loading states explicitly

# Example state structure:
# class XState extends Equatable {
#   final bool isLoading;
#   final List<Item> items;
#   final String? error;
#
#   const XState({
#     this.isLoading = false,
#     this.items = const [],
#     this.error,
#   });
#
#   XState copyWith({...}) => XState(...);
#
#   @override
#   List<Object?> get props => [isLoading, items, error];
# }

# ===============================
# ADMIN ROUTING RULES
# ===============================

# Admin routes defined via enum → typed path extension:
# 
# enum AdminRoutes { dashboard, stations, managers, users, ... }
# 
# extension AdminRoutePath on AdminRoutes {
#   String get path => '/admin/$name';
#   String id(String value) => '$path/$value';
# }
#
# Usage for deep links:
# context.goToAdmin(AdminRoutes.stations.path);
# context.pushToAdminWithId(AdminRoutes.stationDetail, stationId);
#
# NEVER type route strings manually.
# ALWAYS navigate using AdminRoutes enum extension.

# NOTE: Main tab switching should NOT use routes - use state management instead.

# ===============================
# ADMIN UI/UX RULES
# ===============================

# Use ScreenUtil sizing ONLY:
# - Text: fontSize: 14.sp
# - Width: width: 100.w
# - Height: height: 50.h
# - Radius/Padding: 16.r
#
# Icons not too small (min 18.r for admin)
# No text smaller than 11.sp
# Buttons must follow tap target ≥ 44.h
# Clean modern admin UI using reusable widgets only
# No padding/margin hardcoded → make them params
# Responsive: Desktop-first, adapt to tablet/mobile

# Admin-specific UI patterns:
# - Data tables with sorting, filtering, pagination
# - Modal sheets for detail/edit views (slide from right)
# - Filter panels (collapsible)
# - Metric cards for dashboard
# - Status badges/chips
# - Search bars with filters
# - Breadcrumb navigation

# ===============================
# ADMIN THEME ARCHITECTURE
# ===============================

# Inside lib/admin/core/theme/ use separate files:
# - admin_theme.dart          → wraps light/dark
# - admin_light_theme.dart    → ThemeData.light()
# - admin_dark_theme.dart     → ThemeData.dark()
# - admin_theme.dart          → AdminThemeService (switching + persistence)
# - admin_colors.dart         → color palette (same as user app)
# - admin_text_styles.dart    → typography system
#
# Never put ThemeData inside a single big file.
# Use ScreenUtil for text sizing inside text styles.
# All theme values configurable via constants (no hard-coded hex in widgets).

# ===============================
# ADMIN CONTEXT EXTENSIONS
# ===============================

# Use admin context extensions instead of direct calls:
#
# Theme:
# - context.adminColors → AdminAppColors extension
# - context.theme → Theme.of(context)
# - context.colors → theme.colorScheme
# - context.text → theme.textTheme
# - context.isDark → brightness check
#
# Navigation (for deep links only):
# - context.goToAdmin(AdminRoutes.xxx)
# - context.pushToAdmin(AdminRoutes.xxx)
# - context.pushToAdminWithId(AdminRoutes.xxx, id)
#
# Sizing:
# - context.w(8) → 8.w
# - context.h(8) → 8.h
# - context.sp(14) → 14.sp
# - context.r(12) → 12.r

# ===============================
# ADMIN REPOSITORY RULES
# ===============================

# Create repository with dummy implementation:
# - Read from assets/dummy_data/admin/*.json
# - Support pagination, filtering, sorting, searching
# - Simulate CRUD (mutable in-memory list)
# - Expose async APIs
# - Later backend can replace easily (Envato requirement)
# - Repos can contain Flutter imports (rootBundle for JSON)

# ===============================
# ADMIN REUSABLE WIDGET RULES
# ===============================

# All admin screens must use reusable components:
# - AdminShell (sidebar + topbar container)
# - AdminButton (filled, outlined, text, tonal)
# - AdminCard / AdminCardWithHeader
# - AdminDataTable (sorting, filters, pagination)
# - AdminTextField / AdminDropdownField / AdminSearchField
# - AdminMetricCard
# - AdminStatusBadge
# - AdminEmptyState
# - AdminLoading / AdminShimmer
# - AdminDialog / AdminModal
# - AdminFilterPanel
# - AdminBreadcrumb
#
# Each customizable via params.

# ===============================
# ADMIN DOCUMENTATION REQUIREMENTS
# ===============================

# Every file must contain:
# /// File: lib/admin/path/to/file.dart
# /// Purpose: ...
# /// Belongs To: admin/[feature]
# /// Route: AdminRoutes.xxx (if applicable)
# /// Customization Guide:
# ///    - How to change X
# ///    - How to change Y
#
# Add inline comments for non-obvious logic.

# ===============================
# ADMIN RESPONSIVE RULES
# ===============================

# Breakpoints:
# - Mobile: < 768px
# - Tablet: 768px - 1024px
# - Desktop: ≥ 1024px
# - Large Desktop: ≥ 1440px

# Responsive patterns:
# - Sidebar: Collapsed on mobile/tablet, full on desktop
# - Data tables: Scrollable on mobile, full table on desktop
# - Modals: Full-screen on mobile, side panel on desktop
# - Grids: 1 column mobile, 2 tablet, 3-4 desktop

# Use AdminResponsiveBuilder or adminResponsiveValue() helper.

# ===============================
# ADMIN DATA DISPLAY RULES
# ===============================

# Tables:
# - Use AdminDataTable for all list views
# - Include sorting, filtering, pagination
# - Show loading states
# - Show empty states
# - Support row selection (bulk actions)

# Forms:
# - Use AdminTextField, AdminDropdownField, etc.
# - Validate with AdminValidators
# - Show errors inline
# - Use AdminButton for actions

# Modals/Sheets:
# - Detail views: Show in right-side modal/panel
# - Edit/Create: Show in right-side modal/panel
# - Full-screen on mobile, side panel on desktop
# - Use AdminModalSheet.show() via context.showAdminModal() helper
# - ALWAYS use modal sheets for sub-screens (detail, edit, create)
# - NEVER navigate to separate full screens for sub-screens

# ===============================
# CURSOR RULES - AUTOMATED CHECKS
# ===============================

# enforce-admin-structure:
#   Ensure correct admin folder modules under lib/admin/

# require-copywith:
#   Every State class must include copyWith and Equatable.
#   Pattern: class\s+\w+State(?![\s\S]*copyWith)

# require-equatable:
#   All state classes must extend Equatable.
#   Pattern: class\s+\w+State(?![\s\S]*extends\s+Equatable)

# no-hardcoded-strings:
#   Block writing string literals longer than 3 words in UI code.
#   Use AdminStrings constants.

# enforce-admin-routing:
#   Every new admin screen must have AdminRoutes enum entry.
#   But main tabs should use IndexedStack, not routes.

# enforce-barrel-exports:
#   Every folder must have a barrel export file.

# enforce-screenutil:
#   UI must use ScreenUtil for sizing.
#   Pattern: (padding|margin|height|width|fontSize):\s*\d+
#   Use .h/.w/.sp/.r instead.

# enforce-admin-shell:
#   All admin pages must be wrapped in AdminShell.
#   Main tabs should NOT navigate - use IndexedStack.

# ===============================
# WHEN CREATING NEW ADMIN FEATURE
# ===============================

# Cursor must automatically:
# 1. Create feature folder: lib/admin/features/[feature_name]/
# 2. Create BLoC (state/event) if needed
# 3. Create Repository (dummy JSON data)
# 4. Create View pages (List, Detail, Edit)
# 5. Add AdminRoutes enum entry (for deep links)
# 6. Add sidebar item in AdminShell (use IndexedStack, NOT navigation)
# 7. Update barrel file exports
# 8. Add AdminStrings constants
# 9. Add file-level documentation
# 10. Follow all architecture rules

# ===============================
# WHEN MODIFYING EXISTING ADMIN FEATURE
# ===============================

# Cursor must:
# - Only modify specific requested logic
# - Preserve architecture rules
# - Never remove routing / constants
# - Never use hard-coded strings
# - Maintain documentation
# - Keep AdminShell structure intact

# ===============================
# ADMIN NEVER DO
# ===============================

# - Never hardcode text in UI (use AdminStrings)
# - Never use magic numbers (use AdminConfig constants)
# - Never create widget without params
# - Never skip documentation
# - Never break MVVM/BLoC separation
# - Never use setState for business logic
# - Never use Theme.of(context) directly (use context.adminColors)
# - Never use MediaQuery.of(context) directly (use context extensions)
# - Never type raw route strings
# - Never navigate to separate screens for main sidebar tabs (use IndexedStack)
# - Never create full-screen navigation for tab switching
# - Never use go_router for main tab switching (use state management)

# ===============================
# ADMIN ALWAYS DO
# ===============================

# - Use AdminRoutes.pageName for deep links only
# - Use IndexedStack for main tab switching within AdminShell
# - Use context.adminColors for theme access
# - Use context extensions for theme/navigation/sizing
# - Use ScreenUtil (.sp, .h, .w, .r) for all sizing
# - Use AdminStrings for all text
# - Use AdminColors for all colors
# - Create reusable widgets with parameters
# - Add barrel file exports
# - Document all files and methods
# - Use Equatable + copyWith for states
# - Keep UI code clean (no business logic)
# - Show detail/edit views in modals/panels, not full screens
# - Use context.showAdminModal() for ALL sub-screens (detail, edit, create)
# - Keep AdminShell structure with sidebar + topbar
# - Use responsive breakpoints for mobile/tablet/desktop
# - Use AdminModalSheet for consistent sub-screen presentation
# - Ensure modal sheets provide Material context for form fields

# ===============================
# ADMIN SHELL NAVIGATION PATTERN
# ===============================

# Main Admin Shell Structure:
# 
# AdminShell(
#   currentViewIndex: _currentIndex,  // Managed by state
#   onViewChanged: (index) => setState(() => _currentIndex = index),
#   child: IndexedStack(
#     index: _currentIndex,
#     children: [
#       DashboardPage(),
#       StationsPage(),
#       ManagersPage(),
#       UsersPage(),
#       // ... other main tabs
#     ],
#   ),
# )
#
# Sidebar items call onViewChanged(index) instead of context.go()
# Detail/Edit views show in AdminModalSheet via context.showAdminModal()
# Only use go_router for deep links or external navigation

# ===============================
# ADMIN MODAL SHEET NAVIGATION (CRITICAL)
# ===============================

# ALL sub-screens MUST use AdminModalSheet via context.showAdminModal():
# - Detail pages (e.g., StationDetailPage, UserDetailPage)
# - Edit pages (e.g., StationEditPage, UserEditPage)
# - Create pages (e.g., StationCreatePage, UserCreatePage)
# - Any secondary screen that is not a main tab

# Pattern:
# context.showAdminModal(
#   title: AdminStrings.stationsDetailTitle,
#   maxWidth: 1200,  // Desktop max width
#   child: StationDetailPage(stationId: station.id),
# )

# Rules:
# - NEVER use context.push() or context.go() for sub-screens
# - ALWAYS use context.showAdminModal() for detail/edit/create screens
# - Modal sheets are adaptive: full-screen on mobile/tablet, centered dialog on desktop
# - Modal sheets automatically provide Material context for form fields
# - Modal sheets include proper padding (24.w on desktop, 16.w on mobile)
# - Modal sheets handle close button and dismissible behavior
# - Use consistent maxWidth: 800-1000 for forms, 1200+ for detail views

# Examples:
# 
# // ✅ CORRECT: Opening detail page in modal
# AdminButton(
#   label: 'View Details',
#   onPressed: () => context.showAdminModal(
#     title: AdminStrings.stationsDetailTitle,
#     maxWidth: 1200,
#     child: StationDetailPage(stationId: station.id),
#   ),
# )
#
# // ✅ CORRECT: Opening edit page in modal
# AdminButton(
#   label: 'Edit',
#   onPressed: () => context.showAdminModal(
#     title: AdminStrings.stationsEditTitle,
#     maxWidth: 1000,
#     child: StationEditPage(stationId: station.id),
#   ),
# )
#
# // ✅ CORRECT: Opening create page in modal
# AdminButton(
#   label: 'Create',
#   onPressed: () => context.showAdminModal(
#     title: AdminStrings.stationsAddTitle,
#     maxWidth: 1000,
#     child: const StationEditPage(),
#   ),
# )
#
# // ❌ WRONG: Navigating to separate screen
# AdminButton(
#   label: 'View Details',
#   onPressed: () => context.push(AdminRoutes.stationDetail.path),
# )
#
# // ❌ WRONG: Using go_router for sub-screens
# AdminButton(
#   label: 'Edit',
#   onPressed: () => context.go(AdminRoutes.stationEdit.id(stationId)),
# )

# Modal Sheet Implementation:
# - AdminModalSheet automatically handles Material widget wrapping
# - Provides proper Material context for TextField, DropdownButton, etc.
# - Includes responsive behavior (full-screen mobile, centered desktop)
# - Handles padding, scrolling, and close button
# - All sub-screen pages should NOT wrap themselves in AdminShell
# - Sub-screen pages should be pure content widgets

# When creating new sub-screens:
# 1. Create the page widget (e.g., StationDetailPage, StationEditPage)
# 2. Do NOT wrap in AdminShell (modal sheet provides the shell)
# 3. Do NOT use context.push() or context.go() to open
# 4. Always use context.showAdminModal() from parent screen
# 5. Ensure page content has proper Material context (modal provides it)
# 6. Use AdminPageContent for consistent padding if needed

# ===============================
# END OF ADMIN RULES
# ===============================

# ===============================
# USER APP RULES (COMMENTED - NOT APPLICABLE TO ADMIN)
# ===============================

# # The following rules are for the User App, not Admin Panel:
# # - sqflite local caching (admin uses in-memory + JSON)
# # - User app specific features (bookings, favorites, etc.)
# # - User app navigation patterns (bottom tabs, etc.)
# # - User app specific widgets (StationCard, BookingCard, etc.)
